This project is a continuation of the work from 'derive-vector'. The task we try to solve is polymorphic unpacking, i.e. making the following work

> data Foo a = Foo {-# UNPACK #-} !a

so that a 'Foo Int' takes just as much space as 'Int' (currently it takes 2 words more). People such as Johan have said that this is not reasonable with typeclasses: it requires n^2 instances (and this is a very reasonable complaint -- especially when you consider things like lists of pairs; the problem is that, unlike for classes such as 'Binary' or 'Data.Vector.Unboxed.Unbox', we cannot have instances @(Unbox a, Unbox b) => Unbox (a,b)@. This project is merely an attempt to alleviate most of the drudgery required when actually defining the instances, using Template Haskell.

Use should be as follows:

th-unpacking provides:
> data Polymorphic a
> class Unpacked a where
>   mk :: Polymorphic a -> a
>   unMk :: a -> Polymorphic a

containers library writes:
> $(declareType [d| data StrictPair a b = StrictPair !a !b |])
... which expands to ...
> data family StrictPair a b
> data instance Polymorphic (StrictPair a b) = StrictPair !a !b

containers user writes:
> {-# OPTIONS_GHC -funbox-strict-fields #-}
> $(declareInstance Specialised (StrictPair Int Int))
... which expands to ...
> data instance StrictPair Int Int = StrictPair_II !Int !Int
> instance Unpacked (StrictPair Int Int) where
>   mk (StrictPair a b) = StrictPair_II a b
>   unMk (StrictPair_II a b) = StrictPair a b


The problem we run into here is tuples (a,b). The main question is: who should declare them? There is no reasonable answer: ideally, we would only declare them as we need them, but we need GHC not to fuss about conflicting instances.